# -*- coding: utf-8 -*-
"""two_not_touch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BR0VxD-yUjOrQkvERPearXcYZzjD0KPB
"""

from urllib.request import urlopen
import numpy as np
import networkx as nx
from ipywidgets import widgets
from IPython.display import display

class TwoNotTouch:
    
    def __init__(self):
        self.SOLNS = self.get_solutions() # list of all solutions
        self.SHAPES = self.get_shapes() # list of 32 regions with < 6 cells
                
    def get_solutions(self):
        """Returns a list of solutions. Each solution is a list of 20 stars.
           A star in row r and column c is represented by a tuple (r,c)"""
        source = 'https://raw.githubusercontent.com/SumitraMukherjee/TwoNotTouch/main/solutions2nt.txt'
        with urlopen(source) as f: data = [int(v) for v in f.read().decode('utf-8')]
        return [[(j//2, c) for j,c in enumerate(data[20*i:20*(i+1)])] 
                for i in range(len(data)//20)]

    def get_shapes(self):
        """Returns 32 shapes by rotating and flipping 4 basic shapes"""
        M = [np.array(a, int) for a in
            [[[1,0],[0,1]], [[-1,0],[0,1]], [[1,0],[0,-1]], [[-1,0],[0,-1]]]]
        P = [np.array(p, int) for p in [[[1,0],[0,1]], [[0,1],[1,0]]]]
        F = [np.matmul(p,m) for p in P for m in M] 
        B = [np.array(b) for b in 
            [[[0,0],[0,1],[0,2]], [[0,0],[0,1],[1,1],[1,2]],
            [[0,0],[0,1],[0,2],[1,2]], [[0,0],[0,1],[0,2],[1,1],[1,2]]]]
        return [np.matmul(b,f) for b in B for f in F]

    def valid(self, region, stars):
        """A region is valid iff it contains exactly 2 stars"""
        return sum((s in region) for s in stars) == 2

    def get_region(self, stars, cells):
        """Returns a valid region from a set of cells wrt stars"""
        np.random.shuffle(stars) # consider stars in arbitrary order
        for s in stars:
            idx = list(range(len(self.SHAPES))) 
            np.random.shuffle(idx) # try shapes in arbitrary order
            for i in idx:
                chosen = [tuple(s + c) for c in self.SHAPES[i]]
                if self.valid(chosen, stars) and all(c in cells for c in chosen):
                    return chosen
        return False

    def phase1(self, stars):
        """Returns unassigned stars, cells, and formed regions"""
        cells = set((i,j) for i in range(10) for j in range(10))
        regions = []
        for i in range(10):
            chosen = self.get_region(stars, cells)
            if not chosen:
                return stars, cells, regions
            cells = cells - set(chosen)
            stars = [s for s in stars if s not in set(chosen)]
            regions.append(chosen)
        return stars, cells, regions
    
    def get_paths(self, terminal, cells):
        """Returns |terminal|/2 disjoint paths connecting a pairs of terminals"""
        
        terminal = [c for c in terminal]
        np.random.shuffle(terminal) 
        G = nx.grid_2d_graph(10,10)
        taboo = [v for v in G.nodes() if v not in cells]
        G.remove_nodes_from(taboo)
        paths = []
        ct = 0
        while terminal and ct < 10: # until all starred cells have been paired
            terminal = [c for c in terminal]
            np.random.shuffle(terminal)
            ct += 1
            s, t = terminal [:2] # random pair of cells with stars
            if nx.has_path(G, s, t):
                path = nx.shortest_path(G, s, t) # shortest path between (s,t)
                # shorten path to first starred cell in path  
                path = path[:next(i+2 for i,v in enumerate(path[1:]) if v in terminal)]
                terminal.remove(s) # remove s
                terminal.remove(path[-1]) # remove t
                paths.append(path)
                G.remove_nodes_from(path)
        return terminal, paths, set(G.nodes())

    def get_partition(self, stars):
        stars_left, cells_left, regions = self.phase1(stars)
        terminal, paths, cells = self.get_paths(stars_left, cells_left)
        if len(terminal) == 0:
            return cells, regions + paths
        return self.get_partition(stars)

    def assign_unused(self, unused_cells, regions, k):

        def ngbr(rgn, unused):
            def ngbrs(cell):
                r,c = cell 
                return [(r,c-1), (r,c+1), (r-1,c), (r+1,c)]

            for cell in rgn:
                for c in ngbrs(cell):
                    for u in unused:
                        if u == c:
                            return u
            return False

        stable = regions[:k]
        grow = regions[k:]
        while unused_cells and len(grow) > 0:
            j = np.random.randint(0, len(grow))
            rgn = grow[j]
            u = ngbr(rgn, unused_cells)
            if u:
                unused_cells.remove(u)
                grow[j] += [u]
            else:
                grow.remove(grow[j])
                stable += [rgn]
        if len(unused_cells) == 0:
            return stable + grow
        else:
            k = k-1
            return self.assign_unused(unused_cells, stable + grow, k)
        
    def new_puzzle(self, k):
        stars = self.SOLNS[np.random.randint(0, len(self.SOLNS))]
        unused_cells, regions = self.get_partition(stars)
        regions = self.assign_unused(unused_cells, regions, k)
        assert sum(len(r) for r in regions) == 100
        if self.is_unique(regions, stars):
            return sorted(stars), [sorted(rgn) for rgn in sorted(regions)]
        return self.new_puzzle(k)

    def admits(self, partition, stars):
        return all(self.valid(r, stars) for r in partition)

    def is_unique(self, partition, stars):
        for s in self.SOLNS:
            if s != stars and self.admits(partition, s):
                return False
        return True

class TwoNotTouchBoard:
    
    def __init__(self):
        self.COLOR = ['Lavender', 'Pink', 'Orange', 'Yellow', 'PaleGreen', 
                      'Bisque', 'White', 'PowderBlue', 'LightCyan', 'Gainsboro']
        self.CELL = self.get_cell()
        self.BOARD = self.get_board()
        self.MESSAGE = self.get_message()
        self.TNT = TwoNotTouch()
        self.STARS,  self.REGIONS = None, None
        self.DIFFICULTY = widgets.Dropdown(options=['Easy', 'Medium', 'Hard'],
                                           value='Easy', description='Level:')
        self.RESET = self.reset()


    def get_message(self):
        layout = widgets.Layout(width='auto', height='50px')
        button = widgets.Button(description='Done with puzzle.',
                                disabled=False, display='flex', flex_flow='column', 
                                align_items='stretch',layout = layout)
        button.on_click(self.check_solutions)
        return button

    def check_solutions(self, b):
        marked = sorted([cell for cell in self.CELL 
                         if self.CELL[cell].description == '★'])
        if marked == sorted(self.STARS):
            self.MESSAGE.description = 'Congratulations! You win.'
        else:
            self.MESSAGE.description = 'Stars in solution are are marked as ☆'
            for cell in self.STARS:
                self.CELL[cell].description = '☆'

    def get_cell(self):
        layout=widgets.Layout(width='100%', height='25px', border="1px solid")
        style = {'button_color': 'white'}
        CELL = {}
        for cell in [(r,c) for r in range(10) for c in range(10)]:
            CELL[cell] = widgets.Button(layout=layout, style=style)
            CELL[cell].on_click(self.set_mark)
        return CELL

    def set_mark(self, b):
        next_mark = dict(zip([' ', '★', '#', '?'], ['★', '#', '?', ' '])) 
        b.description = next_mark[b.description]
        
    def get_board(self):
        clist = [self.CELL[(r,c)] for r in range(10) for c in range(10)]
        layout=widgets.Layout(grid_template_columns="repeat(10, 25px)", 
                              margin='10px 10px 10px 10px', grid_gap='0.1%' )
        board = widgets.GridBox(children=clist, layout=layout)
        return board

    def new_board(self, b):
        D = dict(zip(['Easy', 'Medium', 'Hard'], [8, 6, 4]))
        k = D[self.DIFFICULTY.value]
        self.MESSAGE.description='Done with puzzle.'
        self.STARS,  self.REGIONS = self.TNT.new_puzzle(k)
        for i,rgn in enumerate(self.REGIONS):
            col = self.COLOR[i]
            for cell in rgn:
                self.CELL[cell].style = {'button_color': col}
                self.CELL[cell].description = ' '

    def reset(self):
        layout = widgets.Layout(width='auto', height='50px')
        NEW_GAME = widgets.Button(description='New puzzle.', disabled=False, 
                                  align_items='stretch', layout = layout)
        NEW_GAME.on_click(self.new_board)
        return NEW_GAME

class PlayTwoNotTouch:

    def __init__(self):
        self.game = TwoNotTouchBoard()

    def launch(self):
        print('Choose difficulty level:')
        display(self.game.DIFFICULTY)
        print('Click the button below for a new puzzle (this maytake quite a few seconds).')
        display(self.game.RESET)
        display(self.game.BOARD)
        print('Click on the button below when done:')
        display(self.game.MESSAGE)
        print()

# PlayTwoNotTouch().launch()